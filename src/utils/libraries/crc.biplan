
// Compute CRC8 with a table-less implementation:
// Copyright Giovanni Blu Mitolo giorscarab@gmail.com 2018

// CRC8 C2, source Baicheva98 (implicit + 1 notation)
// 0x97 = (x + 1)(x^7 + x^6 + x^5 + x^2 + 1)^2
// Chosen because it has the largest possible length (119 bit) at which
// HD=4 can be achieved with 8-bit CRC. 

function crc8_roll($input, locals: $crc, $result)
  for #i = 8 to 0
    $input = $input >> 1
    $result = ($crc ^ $input) & 1;
    $crc = $crc >> 1;
    if $result > 0 $crc = $crc ^ 151 end
  next
return $crc

function crc8_compute($input, $length, locals: $crc) 
  for #b = 0 to length
    $crc = roll(:[$input][b], $crc)
  next
return $crc

// CRC32 table-less implementation
// See: http://www.hackersdelight.org/hdcodetxt/crc.c.txt

// Polynomial

// 0x82608edb = x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
// (0x82608edb; 0x104c11db7) <=> (0xedb88320; 0x1db710641)
//                                  |
//                                bit-reversed polynomial implicit +1 notation
//                                or reverse reciprocal notation

function crc32_compute(
  $data,
  $length,
  $previous,
  locals:
  $bits,
  $crc,
  $current,
  $i
) 
  $bits = 0
  $crc = ~$previous // same as previousCrc32 ^ 0xFFFFFFFF
  $current = :[$data][0]
  while($length) {
    $crc = $crc ^ $current[$i]
    ++$i
    $bits = 8;
    while($bits) 
      if $crc & 1 $crc = ($crc >> 1) ^ 3988292384;
      else $crc = $crc >> 1 end
      --$bits
    next
  next
return ~$crc; // same as crc ^ 0xFFFFFFFF     

function crc32_compare($computed, $received, locals: $r)
  $r = true
  for #i = 4 to 1
    if ($computed >> (8 * (#i - 1))) != received[3 - (#i - 1)]
      $r = false
    end
  next
return $r
